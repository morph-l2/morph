package services

import (
	"context"
	"fmt"
	"math/big"
	"sync"
	"time"

	"morph-l2/tx-submitter/event"
	"morph-l2/tx-submitter/iface"
	"morph-l2/tx-submitter/utils"

	"github.com/morph-l2/go-ethereum/common"
	"github.com/morph-l2/go-ethereum/core/types"
	"github.com/morph-l2/go-ethereum/ethclient"
	"github.com/morph-l2/go-ethereum/log"
)

type Rotator struct {
	// used to record the start time of rotation
	// updated when the sequencerSet, stakingSet or epoch is updated
	startTime    *big.Int // timestamp
	sequencerSet []common.Address
	epoch        *big.Int   // epoch for rotation
	mu           sync.Mutex // lock

	// addrs
	l2SequencerAddr common.Address
	l2GovAddr       common.Address
	l1StakingAddr   common.Address

	// listener
	listener *event.EventListener
	// states generated by listener
	stakerSetChangeTime *big.Int
	listenerStart       bool
}

func NewRotator(l2SeqencerAddr, l2GovAddr common.Address, listener *event.EventListener) *Rotator {
	return &Rotator{
		l2SequencerAddr: l2SeqencerAddr,
		l2GovAddr:       l2GovAddr,
	}
}

func (r *Rotator) StartListen(l1client *ethclient.Client) {

	// history logs
	var curBKNum uint64
	var err error
	for {
		curBKNum, err = l1client.BlockNumber(context.Background())
		if err != nil {
			log.Error("failed to get current block number: %v", err)
			time.Sleep(time.Second * 3)
		} else {
			break
		}

	}

	step := uint64(100)
	end := curBKNum
	start := end - step
	lastBlock := r.listener.GetLastBlockNumber().Uint64()
	filter := r.listener.GetFilter()
	// find the last unprocessed log
	for end >= lastBlock {
		// get latest block numer
		filter.FromBlock = big.NewInt(int64(start))
		filter.ToBlock = big.NewInt(int64(end))
		hLogs, err := l1client.FilterLogs(context.Background(), filter)
		if err != nil {
			log.Error("failed to get history logs: %v", err)
			continue
		} else {
			// process hlogs
			if len(hLogs) > 0 {
				lg := hLogs[len(hLogs)-1]
				// get block
				var block *types.Block
				for {
					block, err = l1client.BlockByNumber(context.Background(), new(big.Int).SetUint64(lg.BlockNumber))
					if err != nil {
						log.Error("failed to get block: %v", err)
						time.Sleep(time.Second * 5)
						continue
					} else {
						r.UpdateStakerSetChangeTime(new(big.Int).SetUint64(block.Time()))
						log.Info("history log found", "block", lg.BlockNumber, "time", block.Time())
						break
					}
				}
				break
			}
			// update range
			end = start
			start = end - step
		}
	}
	// update last block
	r.listener.SetLaskBlockNumber(new(big.Int).SetUint64(curBKNum))
	err = r.listener.SaveLastBlock()
	if err != nil {
		log.Error("failed to save last block number", "err", err)
	}

	r.listenerStart = true
	// start listener
	go r.listener.Listen()
	logChan := r.listener.GetOutputChan()
	// process logs
	for {
		select {
		case lg := <-logChan:
			for {
				bk, err := l1client.BlockByNumber(nil, new(big.Int).SetUint64(lg.BlockNumber))
				if err != nil {
					log.Error("failed to get block by number", "err", err)
					time.Sleep(time.Second * 5)
					continue
				}
				r.UpdateStakerSetChangeTime(new(big.Int).SetUint64(bk.Time()))
				break
			}

		}
	}

}

// UpdateState updates the state of the rotator
// updated by event listener in the future
func (r *Rotator) UpdateState(clients []iface.L2Client) error {

	epochUpdateTime, err := GetEpochUpdateTime(r.l2GovAddr, clients)
	if err != nil {
		log.Error("failed to get epoch update time", "err", err)
		return fmt.Errorf("GetCurrentSubmitter: failed to get epoch update time: %w", err)
	}
	// sequencer set update time
	sequcerUpdateTime, err := GetSequencerSetUpdateTime(r.l2SequencerAddr, clients)
	if err != nil {
		log.Error("failed to get sequencer set update time", "err", err)
		return fmt.Errorf("GetCurrentSubmitter: failed to get sequencer set update time: %w", err)
	}

	r.startTime = utils.MaxOfThreeBig(epochUpdateTime, sequcerUpdateTime, r.stakerSetChangeTime)

	// get current sequencer set
	seqSet, err := GetSequencerSet(r.l2SequencerAddr, clients)
	if err != nil {
		log.Error("failed to get sequencer set", "err", err)
		return fmt.Errorf("UpdateState: failed to get sequencer set: %w", err)
	}
	r.SetSequencerSet(seqSet)
	// get current epoch
	epoch, err := GetEpoch(r.l2GovAddr, clients)
	if err != nil {
		log.Error("failed to get epoch", "err", err)
		return err
	}
	r.epoch = epoch

	return nil
}

func (r *Rotator) UpdateStakerSetChangeTime(t *big.Int) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.stakerSetChangeTime = t
}

// GetCurrentSubmitter returns the current sequencer that should be submitting
func (r *Rotator) CurrentSubmitter(clients []iface.L2Client) (*common.Address, error) {

	err := r.UpdateState(clients)
	if err != nil {
		return nil, fmt.Errorf("update state err: %w", err)
	}

	if len(r.GetSequencerSet()) == 0 {
		return nil, fmt.Errorf("GetCurrentSubmitter: sequencer set is empty")
	}

	if r.epoch.Int64() == 0 {
		return nil, fmt.Errorf("GetCurrentSubmitter: epoch is 0")
	}

	sec := time.Now().Unix() - r.startTime.Int64()
	seqIdx := sec / r.epoch.Int64() % int64(len(r.GetSequencerSet()))

	return &r.GetSequencerSet()[seqIdx], nil

}

func (r *Rotator) SetSequencerSet(newSet []common.Address) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.sequencerSet = newSet
}

func (r *Rotator) GetSequencerSet() []common.Address {
	r.mu.Lock()
	defer r.mu.Unlock()
	return r.sequencerSet

}

// intersaction between sequencerSet & activeStakerSet
func (r *Rotator) Intersaction(a, b []common.Address) []common.Address {
	return nil
}
