// SPDX-License-Identifier: MIT

// MIT License

// Copyright (c) 2022 Optimism
// Copyright (c) 2022 Morph

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pragma solidity =0.8.24;

import {IL2CrossDomainMessenger} from "../IL2CrossDomainMessenger.sol";
import {OwnableBase} from "../../libraries/common/OwnableBase.sol";

// solhint-disable no-empty-blocks
// solhint-disable reason-string

/// @title L2TxFeeVault
/// @notice The L2TxFeeVault contract contains the logic for the vault contracts
///         used to hold fee revenue generated by the L2 system.
contract L2TxFeeVault is OwnableBase {
    /**********
     * Events *
     **********/

    /// @notice Emits each time that a withdrawal occurs.
    ///
    /// @param value Amount that was withdrawn (in wei).
    /// @param to    Address that the funds were sent to.
    /// @param from  Address that triggered the withdrawal.
    event Withdrawal(uint256 value, address to, address from);

    /// @notice Emits each time that a transfer occurs.
    ///
    /// @param value Amount that was transferred (in wei).
    /// @param to    Address that the funds were sent to.
    /// @param from  Address that triggered the transfer.
    event Transfer(uint256 value, address to, address from);

    /// @notice Emits each time the owner updates the address of `messenger`.
    /// @param oldMessenger The address of old messenger.
    /// @param newMessenger The address of new messenger.
    event UpdateMessenger(address indexed oldMessenger, address indexed newMessenger);

    /// @notice Emits each time the owner updates the address of `recipient`.
    /// @param oldRecipient The address of old recipient.
    /// @param newRecipient The address of new recipient.
    event UpdateRecipient(address indexed oldRecipient, address indexed newRecipient);

    /// @notice Emits each time the owner updates the value of `minWithdrawAmount`.
    /// @param oldMinWithdrawAmount The value of old `minWithdrawAmount`.
    /// @param newMinWithdrawAmount The value of new `minWithdrawAmount`.
    event UpdateMinWithdrawAmount(uint256 oldMinWithdrawAmount, uint256 newMinWithdrawAmount);

    /// @notice Emits each time the owner updates the value of `minWithdrawAmount`.
    /// @param account The address of account whose status is changed.
    /// @param status The current receive allowed status.
    event UpdateReceiveAllowed(address account, bool status);

    /// @notice Emitted when account transfer allowed status changed.
    /// @param account The address of account whose status is changed.
    /// @param status The current transfer allowed status.
    event UpdateTransferAllowed(address account, bool status);

    /*************
     * Variables *
     *************/

    /// @notice Minimum balance before a withdrawal can be triggered.
    uint256 public minWithdrawAmount;

    /// @notice Morph L2 messenger address.
    address public messenger;

    /// @notice Wallet that will receive the fees on L1.
    address public recipient;

    /// @notice Total amount of wei processed by the contract.
    uint256 public totalProcessed;

    /// @notice Keep track whether the account is allowed to transfer funds.
    mapping(address transferAddr => bool allowed) public transferAllowed;

    /// @notice Keep track whether the address can receive funds.
    mapping(address receiveAddr => bool allowed) public receiveAllowed;

    /**********************
     * Function Modifiers *
     **********************/

    /// @dev Check if the caller is allowed or owner.
    modifier onlyAllowedAndOwner() {
        require(transferAllowed[msg.sender] || owner == msg.sender, "FeeVault: caller is not allowed");
        _;
    }

    /***************
     * Constructor *
     ***************/

    /// @param _owner               The owner of the contract.
    /// @param _recipient           Wallet that will receive the fees on L1.
    /// @param _minWithdrawalAmount Minimum balance before a withdrawal can be triggered.
    constructor(address _owner, address _recipient, uint256 _minWithdrawalAmount) {
        _transferOwnership(_owner);

        minWithdrawAmount = _minWithdrawalAmount;
        recipient = _recipient;
    }

    /*****************************
     * Public Mutating Functions *
     *****************************/

    /// @notice Allow the contract to receive ETH.
    receive() external payable {}

    /// @notice Triggers a withdrawal of funds to the L1 fee wallet.
    /// @param _value The amount of ETH to withdraw.
    function withdraw(uint256 _value) public onlyOwner {
        require(recipient != address(0), "FeeVault: recipient address cannot be address(0)");
        require(
            _value >= minWithdrawAmount,
            "FeeVault: withdrawal amount must be greater than minimum withdrawal amount"
        );

        uint256 _balance = address(this).balance;
        require(_value <= _balance, "FeeVault: insufficient balance to withdraw");

        unchecked {
            totalProcessed += _value;
        }

        emit Withdrawal(_value, recipient, msg.sender);

        // no fee provided
        IL2CrossDomainMessenger(messenger).sendMessage{value: _value}(
            recipient,
            _value,
            bytes(""), // no message (simple eth transfer)
            0 // _gasLimit can be zero for fee vault.
        );
    }

    /// @notice Triggers a withdrawal of all available funds to the L1 fee wallet.
    function withdraw() external onlyOwner {
        uint256 value = address(this).balance;
        withdraw(value);
    }

    /// @notice Transfer funds to the address.
    /// @param _to The address of recipient.
    /// @param _value The amount of ETH to transfer.
    function transferTo(address _to, uint256 _value) public onlyAllowedAndOwner {
        require(_to != address(0), "FeeVault: recipient address cannot be address(0)");
        require(isReceiveAllowed(_to), "FeeVault: recipient address not allowed");

        uint256 _balance = address(this).balance;
        require(_value <= _balance, "FeeVault: insufficient balance to transfer");

        unchecked {
            totalProcessed += _value;
        }

        emit Transfer(_value, recipient, msg.sender);
        (bool success, ) = _to.call{value: _value}("");
        require(success, "FeeVault: ETH transfer failed");
    }

    /// @notice Transfer all funds to the address.
    /// @param _to The address of recipient.
    function transferTo(address _to) external onlyAllowedAndOwner {
        uint256 value = address(this).balance;
        transferTo(_to, value);
    }

    /************************
     * Restricted Functions *
     ************************/

    /// @notice Update the transfer allowed status
    /// @param _accounts The list of addresses to update.
    /// @param _status The transfer allowed status to update.
    function updateTransferAllowedStatus(address[] memory _accounts, bool _status) external onlyOwner {
        for (uint256 i = 0; i < _accounts.length; i++) {
            transferAllowed[_accounts[i]] = _status;
            emit UpdateTransferAllowed(_accounts[i], _status);
        }
    }

    /// @notice Update the receive allowed status
    /// @param _accounts The list of addresses to update.
    /// @param _status The receive allowed status to update.
    function updateReceiveAllowed(address[] memory _accounts, bool _status) external onlyOwner {
        for (uint256 i = 0; i < _accounts.length; i++) {
            require(_accounts[i] != address(0), "FeeVault: address cannot be address(0)");
            receiveAllowed[_accounts[i]] = _status;
            emit UpdateReceiveAllowed(_accounts[i], _status);
        }
    }

    /// @notice Update the address of messenger.
    /// @param _newMessenger The address of messenger to update.
    function updateMessenger(address _newMessenger) external onlyOwner {
        address _oldMessenger = messenger;
        messenger = _newMessenger;

        emit UpdateMessenger(_oldMessenger, _newMessenger);
    }

    /// @notice Update the address of recipient.
    /// @param _newRecipient The address of recipient to update.
    function updateRecipient(address _newRecipient) external onlyOwner {
        address _oldRecipient = recipient;
        recipient = _newRecipient;

        emit UpdateRecipient(_oldRecipient, _newRecipient);
    }

    /// @notice Update the minimum withdraw amount.
    /// @param _newMinWithdrawAmount The minimum withdraw amount to update.
    function updateMinWithdrawAmount(uint256 _newMinWithdrawAmount) external onlyOwner {
        uint256 _oldMinWithdrawAmount = minWithdrawAmount;
        minWithdrawAmount = _newMinWithdrawAmount;

        emit UpdateMinWithdrawAmount(_oldMinWithdrawAmount, _newMinWithdrawAmount);
    }

    /*************************
     * Public View Functions *
     *************************/

    /// @dev Returns whether the address can receive funds.
    /// @param _to Check whether the address can receive funds.
    function isReceiveAllowed(address _to) public view returns (bool) {
        return receiveAllowed[_to];
    }
}
