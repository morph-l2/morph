package genesis

import (
	"context"
	"encoding/json"
	"fmt"
	"math/big"
	"os"
	"path/filepath"
	"strings"

	"github.com/morph-l2/go-ethereum/common"
	"github.com/morph-l2/go-ethereum/core/types"
	"github.com/morph-l2/go-ethereum/ethclient"
	"github.com/urfave/cli"

	"morph-l2/bindings/hardhat"
	"morph-l2/morph-deployer/morph-chain-ops/genesis"
	node "morph-l2/node/core"
)

var Subcommands = cli.Commands{
	{
		Name:  "l2",
		Usage: "Generates an L2 genesis file and rollup config suitable for a deployed network",
		Flags: []cli.Flag{
			cli.StringFlag{
				Name:  "l1-rpc",
				Usage: "L1 RPC URL",
			},
			cli.StringFlag{
				Name:  "deploy-config",
				Usage: "Path to hardhat deploy config file",
			},
			cli.StringFlag{
				Name:  "deployment-dir",
				Usage: "Path to deployment directory",
			},
			cli.StringFlag{
				Name:  "outfile.l2",
				Usage: "Path to L2 genesis output file",
			},
			cli.StringFlag{
				Name:  "outfile.rollup",
				Usage: "Path to rollup output file",
			},
			cli.StringFlag{
				Name:  "outfile.genbatchheader",
				Usage: "Path to genesisBatchHeader output file",
			},
		},
		Action: func(ctx *cli.Context) error {
			deployConfig := ctx.String("deploy-config")
			config, err := genesis.NewDeployConfig(deployConfig)
			if err != nil {
				return err
			}

			//directly process the deployment file, insteadof deployment-dir
			// deployment-dir will be generated by forge deploy
			depPath := ctx.String("deployment-dir")
			_, network := filepath.Split(depPath)
			network = strings.TrimSuffix(network, filepath.Ext(network))
			hh, err := hardhat.New4SingleDeployment(network, depPath)
			if err != nil {
				return err
			}

			// Read the appropriate deployment addresses from disk
			if err := config.GetDeployedAddresses(hh); err != nil {
				return err
			}

			// Sanity check the config
			//if err := config.Check(); err != nil {
			//	return err
			//}

			client, err := ethclient.Dial(ctx.String("l1-rpc"))
			if err != nil {
				return fmt.Errorf("cannot dial %s: %w", ctx.String("l1-rpc"), err)
			}

			var l1StartBlock *types.Block
			if config.L1StartingBlockTag.BlockHash != nil {
				fmt.Printf("using L1StartingBlockTag.BlockHash: %s\n", config.L1StartingBlockTag.BlockHash)
				l1StartBlock, err = client.BlockByHash(context.Background(), *config.L1StartingBlockTag.BlockHash)
			} else if config.L1StartingBlockTag.BlockNumber != nil {
				fmt.Printf("using L1StartingBlockTag.BlockNumber: %d\n", config.L1StartingBlockTag.BlockNumber.Int64())
				l1StartBlock, err = client.BlockByNumber(context.Background(), big.NewInt(config.L1StartingBlockTag.BlockNumber.Int64()))
			}
			if err != nil {
				return fmt.Errorf("error getting l1 start block: %w", err)
			}
			currentL1Header, err := client.HeaderByNumber(context.Background(), nil)
			if err != nil {
				return fmt.Errorf("error getting l1 current header: %w", err)
			}

			fmt.Printf("The L1 Starting Block Hash: %s \n", l1StartBlock.Hash())

			// Build the developer L2 genesis block
			l2Genesis, withdrawRoot, err := genesis.BuildL2DeveloperGenesis(config, l1StartBlock, currentL1Header)
			if err != nil {
				return fmt.Errorf("error creating l2 developer genesis: %w", err)
			}

			l2GenesisBlock := l2Genesis.ToBlock(nil)
			l2GenesisBlockHash := common.HexToHash(l2GenesisBlock.Hash().Hex())

			var genesisBatchHeaderBytes []byte
			genBatchHeaderFile := ctx.String("outfile.genbatchheader")
			if len(genBatchHeaderFile) > 0 {
				genesisBatchHeader, err := node.GenesisBatchHeader(l2GenesisBlock.Header())
				if err != nil {
					return err
				}
				fmt.Printf("generated genesis batch header bytes: %x \n", genesisBatchHeader.Encode())
				if err := writeGenesisFile(genBatchHeaderFile, genesisBatchHeader); err != nil {
					return err
				}
				genesisBatchHeaderBytes = genesisBatchHeader.EncodedBytes
			}

			rollupConfig, err := config.RollupConfig(l1StartBlock, l2GenesisBlockHash, l2GenesisBlock.Number().Uint64(), l2GenesisBlock.Root(), withdrawRoot, genesisBatchHeaderBytes)
			if err != nil {
				return err
			}

			fmt.Printf("The L2 genesis state root: %s \n", l2GenesisBlock.Root().Hex())

			//if err := rollupConfig.Check(); err != nil {
			//	return fmt.Errorf("generated rollup config does not pass validation: %w", err)
			//}

			if err := writeGenesisFile(ctx.String("outfile.l2"), l2Genesis); err != nil {
				return err
			}
			return writeGenesisFile(ctx.String("outfile.rollup"), rollupConfig)
		},
	},
}

func writeGenesisFile(outfile string, input any) error {
	f, err := os.OpenFile(filepath.Clean(outfile), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o755)
	if err != nil {
		return err
	}
	defer func() { _ = f.Close() }()

	enc := json.NewEncoder(f)
	enc.SetIndent("", "  ")
	return enc.Encode(input)
}
